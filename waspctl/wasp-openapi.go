// Code generated by openapi-cli-generator. DO NOT EDIT.
// See https://github.com/danielgtaylor/openapi-cli-generator

package main

import (
	"fmt"
	"strings"

	"github.com/danielgtaylor/openapi-cli-generator/cli"
	"github.com/pkg/errors"
	"github.com/rs/zerolog/log"
	"github.com/spf13/cobra"
	"github.com/spf13/viper"
	"gopkg.in/h2non/gentleman.v2"
)

var waspOpenapiSubcommand bool

func waspOpenapiServers() []map[string]string {
	return []map[string]string{

		map[string]string{
			"description": "default development server, beware of CORS",
			"url":         "http://localhost:2891",
		},
	}
}

// WaspOpenapiGetBarchJobs GetBarchJobs
func WaspOpenapiGetBarchJobs(params *viper.Viper) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "getbarchjobs"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/batchjobs"

	req := cli.Client.Get().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiInsertBatchJob InsertBatchJob
func WaspOpenapiInsertBatchJob(params *viper.Viper, body string) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "insertbatchjob"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/batchjobs"

	req := cli.Client.Post().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	if body != "" {
		req = req.AddHeader("Content-Type", "text/json").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiUpdateBatchJob UpdateBatchJob
func WaspOpenapiUpdateBatchJob(params *viper.Viper, body string) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "updatebatchjob"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/batchjobs"

	req := cli.Client.Put().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	if body != "" {
		req = req.AddHeader("Content-Type", "text/json").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiDeleteBatchJob DeleteBatchJob
func WaspOpenapiDeleteBatchJob(paramBatchjobname string, params *viper.Viper) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "deletebatchjob"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/batchjobs/{batchjobname}"
	url = strings.Replace(url, "{batchjobname}", paramBatchjobname, 1)

	req := cli.Client.Delete().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiGetBatchJobInstances GetBatchJobInstances
func WaspOpenapiGetBatchJobInstances(paramBatchjobname string, params *viper.Viper) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "getbatchjobinstances"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/batchjobs/{batchjobname}/instances"
	url = strings.Replace(url, "{batchjobname}", paramBatchjobname, 1)

	req := cli.Client.Get().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiGetBatchJobInstance Get batch job instance
func WaspOpenapiGetBatchJobInstance(paramBatchjobname string, paramInstance string, params *viper.Viper) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "get-batch-job-instance"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/batchjobs/{batchjobname}/instances/{instance}"
	url = strings.Replace(url, "{batchjobname}", paramBatchjobname, 1)
	url = strings.Replace(url, "{instance}", paramInstance, 1)

	req := cli.Client.Get().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiStartBatchJob StartBatchJob
func WaspOpenapiStartBatchJob(paramBatchjobname string, params *viper.Viper, body string) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "startbatchjob"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/batchjobs/{batchjobname}/start"
	url = strings.Replace(url, "{batchjobname}", paramBatchjobname, 1)

	req := cli.Client.Post().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	if body != "" {
		req = req.AddHeader("Content-Type", "").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiGetElasticConfig GetElasticConfig
func WaspOpenapiGetElasticConfig(params *viper.Viper) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "getelasticconfig"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/config/es"

	req := cli.Client.Get().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiGetKafkaConfig GetKafkaConfig
func WaspOpenapiGetKafkaConfig(params *viper.Viper) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "getkafkaconfig"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/config/kafka"

	req := cli.Client.Get().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiGetSolrConfig GetSolrConfig
func WaspOpenapiGetSolrConfig(params *viper.Viper) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "getsolrconfig"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/config/sorl"

	req := cli.Client.Get().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiGetSparkBatchConfig GetSparkBatchConfig
func WaspOpenapiGetSparkBatchConfig(params *viper.Viper) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "getsparkbatchconfig"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/config/sparkbatch"

	req := cli.Client.Get().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiGetSparkStreamingConfig GetSparkStreamingConfig
func WaspOpenapiGetSparkStreamingConfig(params *viper.Viper) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "getsparkstreamingconfig"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/config/sparkstreaming"

	req := cli.Client.Get().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiGetTelelemetryConfig GetTelelemetryConfig
func WaspOpenapiGetTelelemetryConfig(params *viper.Viper) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "gettelelemetryconfig"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/config/telemetry"

	req := cli.Client.Get().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiListDocuments ListDocuments
func WaspOpenapiListDocuments(params *viper.Viper) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "listdocuments"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/document"

	req := cli.Client.Get().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiGetDocument GetDocument
func WaspOpenapiGetDocument(paramDocumentname string, params *viper.Viper) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "getdocument"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/document/{documentname}"
	url = strings.Replace(url, "{documentname}", paramDocumentname, 1)

	req := cli.Client.Get().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiEvents Events
func WaspOpenapiEvents(paramSearch string, paramStarttimestamp string, paramEndtimestamp string, paramPage string, paramSize string, params *viper.Viper) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "events"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/events"

	req := cli.Client.Get().URL(url)

	req = req.AddQuery("search", paramSearch)

	req = req.AddQuery("startTimestamp", paramStarttimestamp)

	req = req.AddQuery("endTimestamp", paramEndtimestamp)

	req = req.AddQuery("page", paramPage)

	req = req.AddQuery("size", paramSize)

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiListIndices ListIndices
func WaspOpenapiListIndices(params *viper.Viper) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "listindices"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/index"

	req := cli.Client.Get().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiGetIndex GetIndex
func WaspOpenapiGetIndex(paramIndexname string, params *viper.Viper) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "getindex"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/index/{indexname}"
	url = strings.Replace(url, "{indexname}", paramIndexname, 1)

	req := cli.Client.Get().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiLogs Logs
func WaspOpenapiLogs(paramSearch string, paramStarttimestamp string, paramEndtimestamp string, paramPage string, paramSize string, params *viper.Viper) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "logs"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/logs"

	req := cli.Client.Get().URL(url)

	req = req.AddQuery("search", paramSearch)

	req = req.AddQuery("startTimestamp", paramStarttimestamp)

	req = req.AddQuery("endTimestamp", paramEndtimestamp)

	req = req.AddQuery("page", paramPage)

	req = req.AddQuery("size", paramSize)

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiListMlModels ListMlModels
func WaspOpenapiListMlModels(params *viper.Viper) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "listmlmodels"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/mlmodels"

	req := cli.Client.Get().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiInsertMlModel InsertMlModel
func WaspOpenapiInsertMlModel(params *viper.Viper, body string) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "insertmlmodel"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/mlmodels"

	req := cli.Client.Post().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	if body != "" {
		req = req.AddHeader("Content-Type", "text/json").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiUpdateMlModels UpdateMlModels
func WaspOpenapiUpdateMlModels(params *viper.Viper, body string) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "updatemlmodels"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/mlmodels"

	req := cli.Client.Put().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	if body != "" {
		req = req.AddHeader("Content-Type", "text/json").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiGetMlModel GetMlModel
func WaspOpenapiGetMlModel(paramMlmodelname string, paramMlmodelversion string, params *viper.Viper) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "getmlmodel"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/mlmodels/{mlmodelname}/{mlmodelversion}"
	url = strings.Replace(url, "{mlmodelname}", paramMlmodelname, 1)
	url = strings.Replace(url, "{mlmodelversion}", paramMlmodelversion, 1)

	req := cli.Client.Get().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiDeleteMlModel DeleteMlModel
func WaspOpenapiDeleteMlModel(paramMlmodelname string, paramMlmodelversion string, params *viper.Viper) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "deletemlmodel"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/mlmodels/{mlmodelname}/{mlmodelversion}"
	url = strings.Replace(url, "{mlmodelname}", paramMlmodelname, 1)
	url = strings.Replace(url, "{mlmodelversion}", paramMlmodelversion, 1)

	req := cli.Client.Delete().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiListPipegraphs ListPipegraphs
func WaspOpenapiListPipegraphs(params *viper.Viper) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "listpipegraphs"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/pipegraphs"

	req := cli.Client.Get().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiInsertPipegraph InsertPipegraph
func WaspOpenapiInsertPipegraph(params *viper.Viper, body string) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "insertpipegraph"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/pipegraphs"

	req := cli.Client.Post().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	if body != "" {
		req = req.AddHeader("Content-Type", "text/json").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiUpdatePipegraphs Update Pipegraphs
func WaspOpenapiUpdatePipegraphs(params *viper.Viper, body string) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "update-pipegraphs"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/pipegraphs"

	req := cli.Client.Put().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	if body != "" {
		req = req.AddHeader("Content-Type", "text/json").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiDeletePipegraph DeletePipegraph
func WaspOpenapiDeletePipegraph(paramPipegraphname string, params *viper.Viper) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "deletepipegraph"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/pipegraphs/{pipegraphname}"
	url = strings.Replace(url, "{pipegraphname}", paramPipegraphname, 1)

	req := cli.Client.Delete().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiListPipegraphInstances ListPipegraphInstances
func WaspOpenapiListPipegraphInstances(paramPipegraphname string, params *viper.Viper, body string) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "listpipegraphinstances"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/pipegraphs/{pipegraphname}/instances"
	url = strings.Replace(url, "{pipegraphname}", paramPipegraphname, 1)

	req := cli.Client.Post().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	if body != "" {
		req = req.AddHeader("Content-Type", "").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiGetPipegraphInstance GetPipegraphInstance
func WaspOpenapiGetPipegraphInstance(paramPipegraphname string, paramInstance string, params *viper.Viper) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "getpipegraphinstance"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/pipegraphs/{pipegraphname}/instances/{instance}"
	url = strings.Replace(url, "{pipegraphname}", paramPipegraphname, 1)
	url = strings.Replace(url, "{instance}", paramInstance, 1)

	req := cli.Client.Get().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiStartPipegraph StartPipegraph
func WaspOpenapiStartPipegraph(paramPipegraphname string, params *viper.Viper, body string) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "startpipegraph"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/pipegraphs/{pipegraphname}/start"
	url = strings.Replace(url, "{pipegraphname}", paramPipegraphname, 1)

	req := cli.Client.Post().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	if body != "" {
		req = req.AddHeader("Content-Type", "").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiStopPipegraph StopPipegraph
func WaspOpenapiStopPipegraph(paramPipegraphname string, params *viper.Viper, body string) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "stoppipegraph"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/pipegraphs/{pipegraphname}/stop"
	url = strings.Replace(url, "{pipegraphname}", paramPipegraphname, 1)

	req := cli.Client.Post().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	if body != "" {
		req = req.AddHeader("Content-Type", "").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiGetProducers GetProducers
func WaspOpenapiGetProducers(params *viper.Viper) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "getproducers"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/producers"

	req := cli.Client.Get().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiInsertProducer InsertProducer
func WaspOpenapiInsertProducer(params *viper.Viper, body string) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "insertproducer"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/producers"

	req := cli.Client.Post().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	if body != "" {
		req = req.AddHeader("Content-Type", "text/json").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiUpdateProducer UpdateProducer
func WaspOpenapiUpdateProducer(params *viper.Viper, body string) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "updateproducer"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/producers"

	req := cli.Client.Put().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	if body != "" {
		req = req.AddHeader("Content-Type", "text/json").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiDeleteProducer DeleteProducer
func WaspOpenapiDeleteProducer(paramProducername string, params *viper.Viper) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "deleteproducer"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/producers/{producername}"
	url = strings.Replace(url, "{producername}", paramProducername, 1)

	req := cli.Client.Delete().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiStartProducer StartProducer
func WaspOpenapiStartProducer(paramProducername string, params *viper.Viper, body string) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "startproducer"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/producers/{producername}/start"
	url = strings.Replace(url, "{producername}", paramProducername, 1)

	req := cli.Client.Post().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	if body != "" {
		req = req.AddHeader("Content-Type", "").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiStopProducer StopProducer
func WaspOpenapiStopProducer(paramProducername string, params *viper.Viper, body string) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "stopproducer"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/producers/{producername}/stop"
	url = strings.Replace(url, "{producername}", paramProducername, 1)

	req := cli.Client.Post().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	if body != "" {
		req = req.AddHeader("Content-Type", "").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiGetTopics GetTopics
func WaspOpenapiGetTopics(params *viper.Viper) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "gettopics"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/topics"

	req := cli.Client.Get().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiGetTopic GetTopic
func WaspOpenapiGetTopic(paramTopicname string, params *viper.Viper) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "gettopic"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/topics/{topicname}"
	url = strings.Replace(url, "{topicname}", paramTopicname, 1)

	req := cli.Client.Get().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

func waspOpenapiRegister(subcommand bool) {
	root := cli.Root

	if subcommand {
		root = &cobra.Command{
			Use:   "wasp-openapi",
			Short: "wasp-api",
			Long:  cli.Markdown(""),
		}
		waspOpenapiSubcommand = true
	} else {
		cli.Root.Short = "wasp-api"
		cli.Root.Long = cli.Markdown("")
	}

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "getbarchjobs",
			Short:   "GetBarchJobs",
			Long:    cli.Markdown("Lists all barch jobs"),
			Example: examples,
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, err := WaspOpenapiGetBarchJobs(params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "insertbatchjob",
			Short:   "InsertBatchJob",
			Long:    cli.Markdown("Inserts a new batch job\n## Request Schema (text/json)\n\nproperties:\n  creationTime:\n    format: int64\n    type: integer\n  description:\n    type: string\n  etl:\n    discriminator:\n      propertyName: type\n    oneOf:\n    - $ref: '#/components/schemas/BatchETLModel'\n    - $ref: '#/components/schemas/BatchGdprETLModel'\n  exclusivityConfig:\n    $ref: '#/components/schemas/BatchJobExclusionConfig'\n  name:\n    type: string\n  owner:\n    type: string\n  system:\n    type: boolean\nrequired:\n- name\n- description\n- owner\n- system\n- creationTime\n- etl\n- exclusivityConfig\ntype: object\nxml:\n  name: BatchJobModel\n  namespace: java://it.agilelab.bigdata.wasp.core.models\n"),
			Example: examples,
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("text/json", args[0:])
				if err != nil {
					log.Fatal().Err(err).Msg("Unable to get body")
				}

				_, decoded, err := WaspOpenapiInsertBatchJob(params, body)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "updatebatchjob",
			Short:   "UpdateBatchJob",
			Long:    cli.Markdown("Inserts a new batch job\n## Request Schema (text/json)\n\nproperties:\n  creationTime:\n    format: int64\n    type: integer\n  description:\n    type: string\n  etl:\n    discriminator:\n      propertyName: type\n    oneOf:\n    - $ref: '#/components/schemas/BatchETLModel'\n    - $ref: '#/components/schemas/BatchGdprETLModel'\n  exclusivityConfig:\n    $ref: '#/components/schemas/BatchJobExclusionConfig'\n  name:\n    type: string\n  owner:\n    type: string\n  system:\n    type: boolean\nrequired:\n- name\n- description\n- owner\n- system\n- creationTime\n- etl\n- exclusivityConfig\ntype: object\nxml:\n  name: BatchJobModel\n  namespace: java://it.agilelab.bigdata.wasp.core.models\n"),
			Example: examples,
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("text/json", args[0:])
				if err != nil {
					log.Fatal().Err(err).Msg("Unable to get body")
				}

				_, decoded, err := WaspOpenapiUpdateBatchJob(params, body)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "deletebatchjob batchjobname",
			Short:   "DeleteBatchJob",
			Long:    cli.Markdown("Deletes a Batch Job"),
			Example: examples,
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, err := WaspOpenapiDeleteBatchJob(args[0], params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "getbatchjobinstances batchjobname",
			Short:   "GetBatchJobInstances",
			Long:    cli.Markdown("Lists all instances of a batch job"),
			Example: examples,
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, err := WaspOpenapiGetBatchJobInstances(args[0], params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "get-batch-job-instance batchjobname instance",
			Short:   "Get batch job instance",
			Long:    cli.Markdown("Get a batch job instance"),
			Example: examples,
			Args:    cobra.MinimumNArgs(2),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, err := WaspOpenapiGetBatchJobInstance(args[0], args[1], params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "startbatchjob batchjobname",
			Short:   "StartBatchJob",
			Long:    cli.Markdown("Starts a batch job"),
			Example: examples,
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("", args[1:])
				if err != nil {
					log.Fatal().Err(err).Msg("Unable to get body")
				}

				_, decoded, err := WaspOpenapiStartBatchJob(args[0], params, body)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "getelasticconfig",
			Short:   "GetElasticConfig",
			Long:    cli.Markdown("Retrieves the configuration used to connect to elastic"),
			Example: examples,
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, err := WaspOpenapiGetElasticConfig(params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "getkafkaconfig",
			Short:   "GetKafkaConfig",
			Long:    cli.Markdown("Retrieves the configuration used to connect to Kafka"),
			Example: examples,
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, err := WaspOpenapiGetKafkaConfig(params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "getsolrconfig",
			Short:   "GetSolrConfig",
			Long:    cli.Markdown("Retrieves the configuration used to connect to solr"),
			Example: examples,
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, err := WaspOpenapiGetSolrConfig(params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "getsparkbatchconfig",
			Short:   "GetSparkBatchConfig",
			Long:    cli.Markdown("Retrieves the configuration of the Spark Batch context"),
			Example: examples,
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, err := WaspOpenapiGetSparkBatchConfig(params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "getsparkstreamingconfig",
			Short:   "GetSparkStreamingConfig",
			Long:    cli.Markdown("Retrieves the configuration of the Spark Streaming context"),
			Example: examples,
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, err := WaspOpenapiGetSparkStreamingConfig(params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "gettelelemetryconfig",
			Short:   "GetTelelemetryConfig",
			Long:    cli.Markdown("Retrieves the configuration of the telemetry subsystem"),
			Example: examples,
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, err := WaspOpenapiGetTelelemetryConfig(params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "listdocuments",
			Short:   "ListDocuments",
			Long:    cli.Markdown("Retrieves all models used to write or read from Document Stores"),
			Example: examples,
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, err := WaspOpenapiListDocuments(params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "getdocument documentname",
			Short:   "GetDocument",
			Long:    cli.Markdown("Retrieves the model used to write or read from Document Stores"),
			Example: examples,
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, err := WaspOpenapiGetDocument(args[0], params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "events search starttimestamp endtimestamp page size",
			Short:   "Events",
			Long:    cli.Markdown("Retrieves events entries"),
			Example: examples,
			Args:    cobra.MinimumNArgs(5),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, err := WaspOpenapiEvents(args[0], args[1], args[2], args[3], args[4], params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "listindices",
			Short:   "ListIndices",
			Long:    cli.Markdown("Retrieve all models used to read or write indexed Data Stores"),
			Example: examples,
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, err := WaspOpenapiListIndices(params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "getindex indexname",
			Short:   "GetIndex",
			Long:    cli.Markdown("Retrieves all models used to read or write Indexed data stores"),
			Example: examples,
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, err := WaspOpenapiGetIndex(args[0], params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "logs search starttimestamp endtimestamp page size",
			Short:   "Logs",
			Long:    cli.Markdown("Retrieves logs entries"),
			Example: examples,
			Args:    cobra.MinimumNArgs(5),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, err := WaspOpenapiLogs(args[0], args[1], args[2], args[3], args[4], params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "listmlmodels",
			Short:   "ListMlModels",
			Long:    cli.Markdown("Retrieve all machine learning models info"),
			Example: examples,
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, err := WaspOpenapiListMlModels(params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "insertmlmodel",
			Short:   "InsertMlModel",
			Long:    cli.Markdown("Inserts a new MlModel\n## Request Schema (text/json)\n\nproperties:\n  _id:\n    nullable: true\n    type: string\n  className:\n    nullable: true\n    type: string\n  description:\n    type: string\n  favorite:\n    type: boolean\n  modelFileId:\n    nullable: true\n    type: string\n  name:\n    type: string\n  timestamp:\n    format: int64\n    nullable: true\n    type: integer\n  version:\n    type: string\nrequired:\n- name\n- version\n- favorite\n- description\ntype: object\nxml:\n  name: MlModelOnlyInfo\n  namespace: java://it.agilelab.bigdata.wasp.core.models\n"),
			Example: examples,
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("text/json", args[0:])
				if err != nil {
					log.Fatal().Err(err).Msg("Unable to get body")
				}

				_, decoded, err := WaspOpenapiInsertMlModel(params, body)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "updatemlmodels",
			Short:   "UpdateMlModels",
			Long:    cli.Markdown("Updates a machine learning model\n## Request Schema (text/json)\n\nproperties:\n  _id:\n    nullable: true\n    type: string\n  className:\n    nullable: true\n    type: string\n  description:\n    type: string\n  favorite:\n    type: boolean\n  modelFileId:\n    nullable: true\n    type: string\n  name:\n    type: string\n  timestamp:\n    format: int64\n    nullable: true\n    type: integer\n  version:\n    type: string\nrequired:\n- name\n- version\n- favorite\n- description\ntype: object\nxml:\n  name: MlModelOnlyInfo\n  namespace: java://it.agilelab.bigdata.wasp.core.models\n"),
			Example: examples,
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("text/json", args[0:])
				if err != nil {
					log.Fatal().Err(err).Msg("Unable to get body")
				}

				_, decoded, err := WaspOpenapiUpdateMlModels(params, body)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "getmlmodel mlmodelname mlmodelversion",
			Short:   "GetMlModel",
			Long:    cli.Markdown("Retrieves data on a specific Machine Learning model"),
			Example: examples,
			Args:    cobra.MinimumNArgs(2),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, err := WaspOpenapiGetMlModel(args[0], args[1], params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "deletemlmodel mlmodelname mlmodelversion",
			Short:   "DeleteMlModel",
			Long:    cli.Markdown("Delete a Machine learning model"),
			Example: examples,
			Args:    cobra.MinimumNArgs(2),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, err := WaspOpenapiDeleteMlModel(args[0], args[1], params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "listpipegraphs",
			Short:   "ListPipegraphs",
			Long:    cli.Markdown("Lists all pipegraphs"),
			Example: examples,
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, err := WaspOpenapiListPipegraphs(params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "insertpipegraph",
			Short:   "InsertPipegraph",
			Long:    cli.Markdown("Inserts a pipegraph\n## Request Schema (text/json)\n\nproperties:\n  creationTime:\n    format: int64\n    type: integer\n  dashboard:\n    $ref: '#/components/schemas/DashboardModel'\n  description:\n    type: string\n  isSystem:\n    type: boolean\n  legacyStreamingComponents:\n    items:\n      $ref: '#/components/schemas/LegacyStreamingETLModel'\n    type: array\n  name:\n    type: string\n  owner:\n    type: string\n  rtComponents:\n    items:\n      $ref: '#/components/schemas/RTModel'\n    type: array\n  structuredStreamingComponents:\n    items:\n      $ref: '#/components/schemas/StructuredStreamingETLModel'\n    type: array\nrequired:\n- name\n- description\n- owner\n- isSystem\n- creationTime\n- legacyStreamingComponents\n- structuredStreamingComponents\n- rtComponents\ntype: object\nxml:\n  name: PipegraphModel\n  namespace: java://it.agilelab.bigdata.wasp.core.models\n"),
			Example: examples,
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("text/json", args[0:])
				if err != nil {
					log.Fatal().Err(err).Msg("Unable to get body")
				}

				_, decoded, err := WaspOpenapiInsertPipegraph(params, body)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "update-pipegraphs",
			Short:   "Update Pipegraphs",
			Long:    cli.Markdown("updateds a pipegraph\n## Request Schema (text/json)\n\nproperties:\n  creationTime:\n    format: int64\n    type: integer\n  dashboard:\n    $ref: '#/components/schemas/DashboardModel'\n  description:\n    type: string\n  isSystem:\n    type: boolean\n  legacyStreamingComponents:\n    items:\n      $ref: '#/components/schemas/LegacyStreamingETLModel'\n    type: array\n  name:\n    type: string\n  owner:\n    type: string\n  rtComponents:\n    items:\n      $ref: '#/components/schemas/RTModel'\n    type: array\n  structuredStreamingComponents:\n    items:\n      $ref: '#/components/schemas/StructuredStreamingETLModel'\n    type: array\nrequired:\n- name\n- description\n- owner\n- isSystem\n- creationTime\n- legacyStreamingComponents\n- structuredStreamingComponents\n- rtComponents\ntype: object\nxml:\n  name: PipegraphModel\n  namespace: java://it.agilelab.bigdata.wasp.core.models\n"),
			Example: examples,
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("text/json", args[0:])
				if err != nil {
					log.Fatal().Err(err).Msg("Unable to get body")
				}

				_, decoded, err := WaspOpenapiUpdatePipegraphs(params, body)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "deletepipegraph pipegraphname",
			Short:   "DeletePipegraph",
			Long:    cli.Markdown("Deletes a pipegraph"),
			Example: examples,
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, err := WaspOpenapiDeletePipegraph(args[0], params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "listpipegraphinstances pipegraphname",
			Short:   "ListPipegraphInstances",
			Long:    cli.Markdown("List all instances of a pipegraph"),
			Example: examples,
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("", args[1:])
				if err != nil {
					log.Fatal().Err(err).Msg("Unable to get body")
				}

				_, decoded, err := WaspOpenapiListPipegraphInstances(args[0], params, body)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "getpipegraphinstance pipegraphname instance",
			Short:   "GetPipegraphInstance",
			Long:    cli.Markdown("Retrieves a pipegraph instance"),
			Example: examples,
			Args:    cobra.MinimumNArgs(2),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, err := WaspOpenapiGetPipegraphInstance(args[0], args[1], params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "startpipegraph pipegraphname",
			Short:   "StartPipegraph",
			Long:    cli.Markdown("Starts a new instance of pipegraph"),
			Example: examples,
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("", args[1:])
				if err != nil {
					log.Fatal().Err(err).Msg("Unable to get body")
				}

				_, decoded, err := WaspOpenapiStartPipegraph(args[0], params, body)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "stoppipegraph pipegraphname",
			Short:   "StopPipegraph",
			Long:    cli.Markdown("Stops the running instance of a pipegrah"),
			Example: examples,
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("", args[1:])
				if err != nil {
					log.Fatal().Err(err).Msg("Unable to get body")
				}

				_, decoded, err := WaspOpenapiStopPipegraph(args[0], params, body)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "getproducers",
			Short:   "GetProducers",
			Long:    cli.Markdown("Retrieves all producers"),
			Example: examples,
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, err := WaspOpenapiGetProducers(params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "insertproducer",
			Short:   "InsertProducer",
			Long:    cli.Markdown("Inserts a producer\n## Request Schema (text/json)\n\nproperties:\n  className:\n    type: string\n  configuration:\n    nullable: true\n    type: string\n  isActive:\n    type: boolean\n  isRemote:\n    type: boolean\n  isSystem:\n    type: boolean\n  name:\n    type: string\n  topicName:\n    nullable: true\n    type: string\nrequired:\n- name\n- className\n- isActive\n- isRemote\n- isSystem\ntype: object\nxml:\n  name: ProducerModel\n  namespace: java://it.agilelab.bigdata.wasp.core.models\n"),
			Example: examples,
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("text/json", args[0:])
				if err != nil {
					log.Fatal().Err(err).Msg("Unable to get body")
				}

				_, decoded, err := WaspOpenapiInsertProducer(params, body)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "updateproducer",
			Short:   "UpdateProducer",
			Long:    cli.Markdown("Updates a new producer\n## Request Schema (text/json)\n\nproperties:\n  className:\n    type: string\n  configuration:\n    nullable: true\n    type: string\n  isActive:\n    type: boolean\n  isRemote:\n    type: boolean\n  isSystem:\n    type: boolean\n  name:\n    type: string\n  topicName:\n    nullable: true\n    type: string\nrequired:\n- name\n- className\n- isActive\n- isRemote\n- isSystem\ntype: object\nxml:\n  name: ProducerModel\n  namespace: java://it.agilelab.bigdata.wasp.core.models\n"),
			Example: examples,
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("text/json", args[0:])
				if err != nil {
					log.Fatal().Err(err).Msg("Unable to get body")
				}

				_, decoded, err := WaspOpenapiUpdateProducer(params, body)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "deleteproducer producername",
			Short:   "DeleteProducer",
			Long:    cli.Markdown("Deletes a producer"),
			Example: examples,
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, err := WaspOpenapiDeleteProducer(args[0], params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "startproducer producername",
			Short:   "StartProducer",
			Long:    cli.Markdown("Start a producer"),
			Example: examples,
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("", args[1:])
				if err != nil {
					log.Fatal().Err(err).Msg("Unable to get body")
				}

				_, decoded, err := WaspOpenapiStartProducer(args[0], params, body)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "stopproducer producername",
			Short:   "StopProducer",
			Long:    cli.Markdown("Stop a producerj"),
			Example: examples,
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("", args[1:])
				if err != nil {
					log.Fatal().Err(err).Msg("Unable to get body")
				}

				_, decoded, err := WaspOpenapiStopProducer(args[0], params, body)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "gettopics",
			Short:   "GetTopics",
			Long:    cli.Markdown("Lists all models used to write or read from message queues"),
			Example: examples,
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, err := WaspOpenapiGetTopics(params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "gettopic topicname",
			Short:   "GetTopic",
			Long:    cli.Markdown("Retrieves the model used to write or read from message queues"),
			Example: examples,
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, err := WaspOpenapiGetTopic(args[0], params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

}
